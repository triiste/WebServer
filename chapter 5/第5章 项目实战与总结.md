# 第5章 项目实战与总结

## 1.阻塞和非阻塞、同步和异步(网络IO)

### 网络IO阶段1 数据就绪
操作系统

- 阻塞

	- 调用IO方法的线程进入阻塞状态

		- size_t recv(int sockfd,void *buf,size_t len,int flags);

			- 数据未到达，线程挂起

		- int size = recv(sockfd,buf,1024,0);

			- size == -1,出错了 (EINTR,EAGAIN,EWOULDBLOCK);
size == 0,读取到数据的末尾，对方连接关闭
size > 0,读取到了多少数据

- 非阻塞

	- 不会改变线程的状态,通过返回值判断

### 网络IO阶段2 数据读写
应用程序

- 同步

	- char buf[1024] = {0};
int size = recv(sockfd,buf,1024,0);

		- 数据读写全由应用层解决

- 异步

	- 异步IO接口
sockfd buf 通知方式

		- 操作系统发现有数据保存到buf当中
		- 应用程序玩自己的了
		- 通知方式

			- sigio信号

### 陈硕：在处理IO的时候，阻塞和非阻塞都是同步IO,只有使用了特殊的API才是异步IO

### IO多路复用是同步的

## 2.Unix、Linux上的五种IO模型

### a.阻塞 blocking

- 调用者调用了某个函数，等待这个函数返回，期间什么也不做，不停的去检查这个函数有没有返回，必须等待这个函数返回才能进行下一步动作
- 

### b.非阻塞 non-blocking

- 非阻塞等待，每隔一段时间就去检测IO事件是否就绪。没有就绪就可以做其他事。非阻塞I/O执行系统调用总是立即返回，不管事件是否已经发生，若事件没有发生，则返回-1，此时可以根据errno区分这两种情况，对于accept,recv和send，事件未发生时，errno通常被设置成EAGAIN
- 

### c.IO复用(IO multiplexing)

- Linux用select/poll/epoll 函数实现IO复用模型，这些函数会使进程阻塞，但是和阻塞IO所不同的是这些函数可以同时阻塞多个IO操作。而且可以同时对多个读操作、写操作的IO函数进行检测。而且可以同时对多个读操作、写操作的IO函数进行检测，直到有数据可读或可写时，才真正调用IO操作函数
- 

### d.信号驱动(signal-driven)

- Linux用套接字进行信号驱动IO，安装一个信号处理函数，进程继续运行并不阻塞，当IO事件就绪，进程收到SIGIO信号，然后处理IO事件
- 
- 内核在第一个阶段是异步，在第二个阶段是同步；与非阻塞IO的区别在于它提供了消息通知机制，不需要用户进程不断的轮询检查，减少了系统API的调用次数，提高了效率

### e.异步(asynchronous)

- Linux中，可以调用aio_read函数告诉内核描述字缓冲区指针和缓冲区的大小、文件偏移及通知的方式，然后立即返回，当内核将数据拷贝到缓冲区后，再通知应用程序
- 

## 3.Web Server(网页服务器)

### 一个Web Server就是一个服务器软件(程序)，或者是运行这个服务器软件的硬件(计算机)。其主要功能是通过HTTP协议与客户端(通常是浏览器(Browser))进行通信，来接收，存储，处理来自客户端的HTTP请求，并对其请求做出HTTP响应，返回给客户端其请求的内容(文件、网页等)或返回一个Error信息

### HTTP协议(应用层的协议)

- 简介

	- 超文本传输协议(HTTP)是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII形式给出;而消息内容则具有一个类似MIME的格式。HTTP是万维网的数据通信的基础

- 默认是80端口
- HTTP请求/响应的步骤

	- 1.客户端连接到web服务器
	- 2.发送HTTP请求
	- 3.服务器接受请求并返回HTTP响应
	- 4.释放连接TCP连接
	- 5.客户端浏览器解析HTML内容

- 在浏览器地址栏键入URL,按下回车之后会经历以下流程：

	- 1.浏览器向DNS服务器请求解析该URL中的域名所对应的IP地址
	- 2.解析出IP地址后，根据IP地址和默认端口80，和服务器建立TCP连接
	- 3.浏览器发出读取文件(URL中域名后面部分对应的文件)的HTTP请求，该请求报文作为TCP三次握手的第三个报文的数据发送给服务器
	- 4.服务器对浏览器请求作出响应，并把对应的HTML文本发送给浏览器
	- 5.释放TCP连接
	- 6.浏览器将该HTML文本渲染并显示内容

- HTTP协议规定，请求从客户端发出，最后服务器端响应该请求并返回。

## 4.服务器编程基本框架

### I/O处理单元

- 处理客户连接，读写网络数据

### 逻辑单元

- 业务进程或线程

### 网络存储单元

- 数据库、文件或缓存

### 请求队列

- 各单元之间的通信方式

### I/O处理单元是服务器管理客户连接的模块。它通常要完成以下工作：等待并接受新的客户连接，接收客户数据，将服务器响应数据返回给客户端。但是数据的收发不一定在I/O处理单元中执行，也可能在逻辑单元中执行，具体在何处执行取决于事件处理模式

### 一个逻辑单元通常是一个进程或线程。它分析并处理客户数据，然后将结果传递给I/O处理单元或者直接发送给客户端(具体使用哪种方式取决于事件处理模式)。服务器通常有多个逻辑单元，以实现对多个客户任务的并发处理

### 网络存储单元可以是数据库、缓存和文件，但不是必须的

### 请求队列是各单元之间的通信方式的抽象。I/O处理单元接收到客户请求时，需要以某种方式通知一个逻辑单元来处理该请求。同样，多个逻辑单元同时访问一个存储单元时，也需要采用某种机制来协调处理竞态条件。请求队列通常被实现为池的一部分

## 5.两种高效的事件处理模式

### 服务器程序通常需要处理三类事件：I/O事件、信号及定时事件。有两种高效的事件处理模式：Reactor和Proactor,同步IO模型通常用于实现Reactor模式，异步I/O模型通常用于实现Proactor模式

### Reactor模式

- 要求主线程(I/O处理单元)只负责监听文件描述符上是否有事件发生，有的话就立即将该事件通知工作线程(逻辑单元)，将socket可读可写事件放入请求队列，交给工作线程处理。除此之外，主线程不做任何其他实质性的工作。读写数据，接受新的连接，以及处理客户请求均在工作线程中完成
- 使用同步I/O(以 epoll_wait 为例)实现的Reactor 模式的工作流程是：

	- 1.主线程往epoll内核事件表中注册socket的读就绪事件
	- 2.主线程调用epoll_wait等待socket上有数据可读
	- 3.当socket上有数据可读时，epoll_wait通知主线程。主线程则将socket可读事件放入请求队列
	- 4.睡眠在请求队列上的某个工作线程被唤醒，它从socket读取数据，并处理客户请求，然后往epoll内核事件表中注册该socket上的写就绪事件
	- 5.当主线程调用epoll_wait等待socket可写
	- 6.当socket可写时，epoll_wait通知主线程。主线程将socket可写事件放入请求队列
	- 7.睡眠在请求队列上的某个工作线程被唤醒，它往socket上写入服务器处理客户端请求的结果
	- 

### Proactor模式

- Proactor模式将所有I/O操作都交给主线程和内核来处理(进行读、写)，工作线程仅仅负责业务逻辑。使用异步I/O模型(以aio_read和aio_write为例)实现的Proactor模式的工作流程是

	- 1.主线程调用aio_read函数向内核注册socket上的读完成事件，并告诉内核用户缓冲区的位置，以及读操作完成时如何通知应用程序(这里以信号为例)
	- 2.主线程继续处理其他逻辑
	- 3.当socket上的数据被读入用户缓冲区后，内核将向应用程序发送一个信号，以通知应用程序数据已经可用
	- 4.应用程序预先定义好的信号处理函数选择一个工作线程来处理客户请求。工作线程处理完客户请求后，调用aio_write向内核注册socket上的写完成事件，并告诉内核用户写缓冲区的位置，以及写操作完成时如何通知应用程序
	- 5.主线程继续处理其他逻辑
	- 6.当用户缓冲区的数据被写入socket之后，内核将向应用程序发送一个信号，以通知应用程序数据已经发送完毕
	- 7.应用程序预先定义好的信号处理函数选择一个工作线程来做善后处理，比如决定是否关闭socket

## 6.线程池

### 线程池是由服务器预习创建的一组子线程，线程池中的线程数量应该和CPU数量差不多。线程池中的所有子线程都运行着相同的代码。当有新的任务到来时，主线程将通过某种方式选择线程池中的某一个子线程来为之服务。相比与动态的创建子线程，选择一个已经存在的子线程的代价显然要小得多。至于主线程选择哪个子线程来为新任务服务，则有多种方式：

- 主线程使用某种算法来主动选择子线程。更均匀地分配，从而减轻服务器的整体压力
- 主线程和所有子线程通过一个共享的工作队列来同步，子线程都睡眠在该工作队列上。当有新的任务到来时，主线程将任务添加到工作队列中。这将唤醒正在等待任务的子线程，不过只有一个子线程将获得新任务的“接管权”，它可以从工作队列中取出任务并执行之，而其他子线程将继续睡眠在工作队列上

### 空间换时间，浪费服务器的硬件资源，换取运行效率

### 池是一组资源的集合，这组资源在服务器启动之初就被完全创建好并初始化，这称为静态资源

### 当服务器进入正式运行阶段，开始处理客户请求的时候，如果它需要相关的资源，可以直接从池中获取，无需动态分配

### 当服务器处理完一个客户连接后，可以把相关的资源放回池中，无需执行系统调用释放资源

## 7.有限状态机

### 逻辑单元内部的一种高效编程方法：有限状态机(finite state machine)

### 有的应用层协议头部包含数据包类型字段，每种类型可以映射为逻辑单元的一种执行状态，服务器可以根据它来编写相应的处理逻辑。

## 8.服务器压力测试

### Webbench是linux上一款知名的、优秀的web性能压力测试工具

- 测试处在相同硬件上，不同服务器的性能以及不同硬件上的同一个服务的运行状况
- 展示服务器的两项内容：每秒钟响应请求数和每秒钟传输数据量
- 基本原理：Webbench 首先fork出多个子进程，每个子进程都循环做web访问测试。子进程把访问的结果通过pipe告诉父进程，父进程做最终的统计结果

### 测试示例

- webbench -c 1000 -t 30 http://192.168.111.155:10000/index.html
- 参数

	- -c 表示客户端数
	- -t 表示时间

