# 第3章 LInux多线程开发

## 线程概述

### 与进程类似，线程是允许应用程序并发执行多个任务的一种机制。

### 一个进程可以包含多个线程

### 同一个程序中的所有线程均会独立执行相同程序，且共享同一份全局内存区域，其中包括初始化数据段、未初始化数据段，以及堆内存段。

### 进程是CPU分配资源的最小单位，线程是操作系统调度执行的最小单位

### 线程和进程的区别

- 进程间的信息难以共享
- 进程调用fork()来创建进程的代价相对较高，即利用写时复制技术
- 线程之间能够方便、快速地共享信息
- 创建线程比创建进程通常要快10倍甚至更多。线程间是共享虚拟地址空间地，无需采用写时复制来复制内存，也无需复制页表

### 线程之间共享和非共享资源

- 共享资源

	- 进程ID和父进程ID
	- 用户ID和用户组ID
	- 进程组ID和会话ID
	- 文件描述符表
	- 信号处置
	- 文件系统的相关信息：文件权限掩码(umask)、当前工作目录
	- 虚拟地址空间(除栈、.text)

- 非共享资源

	- 线程ID
	- 信号掩码
	- 线程特有数据
	- error变量
	- 实时调度策略和优先级
	- 栈、本地变量和函数的调用链接信息

## 线程操作

### 创建线程

- int pthread_create(pthread_t *thread, const pthread_attr_t *attr,void *(*start_routine) (void *), void *arg);

	- - 功能：创建一个子线程
	- - 参数

		- - thread：传出参数，线程创建成功后，子线程的线程ID被写到该变量中
		- - attr：设置线程的属性，一般使用默认值，NULL
		- - start_routine：函数指针，这个函数是子线程需要处理的逻辑代码
		- - arg：给第三个参数使用，传参

	- - 返回值

		- 成功：0
		- 失败：返回错误号。这个错误号和之前errno不太一样
		- 获取错误号的信息：char * strerror(int errnum)

### 终止线程

-  void pthread_exit(void *retval);

	- 功能

		- 终止一个线程。在哪个线程中调用，就表示终止哪个线程

	- 参数

		- - retval：需要传递一个指针，作为一个返回值，可以在pthread_join()中获取到

	- 无返回值
	- 当主线程退出时，不会影响其他正常运行的线程

### 连接已终止的线程

- int pthread_join(pthread_t thread, void **retval);

	- - 功能：和一个已经终止的线程进行连接

		- 回收子线程的资源
		- 这个函数是阻塞函数，调用一次只能回收一个子线程
		- 一般在主线程中使用

	- - 参数

		- -thread：需要回收的子线程的ID
		- -retval：接收子线程退出时的返回值

	- - 返回值

		- 0：成功
		- 非0：失败，返回的错误号

### 线程的分离

- int pthread_detach(pthread_t thread); 

	- 功能：分离一个线程。被分离的线程在终止的时候，会自动释放资源返回给系统

		- 1.不能多次分离，会产生不可预料的行为
		- 2.不能去连接一个已经分离的线程，会报错

	- 参数

		- 需要分离的线程的ID

	- 返回值

		- 成功：0
		- 失败：返回错误号

### 线程的取消

- int pthread_cancel(pthread_t thread);

	- 功能：取消线程(让线程终止)

		- 取消某个线程，可以终止某个线程的运行，但是并不是立马终止，而是当子线程执行到一个取消点，线程才会终止
		- 取消点：系统规定好的一些系统调用，我们可以粗略的理解为从用户区到内核区的切换，这个位置称之为取消点。

### 线程属性

### 线程同步

- 线程的主要优势在于，能够通过全局变量来共享信息，不过，这种便携的共享是有代价的：必须确保多个线程不会同时修改同一变量，或者某一线程不会读取正在由其他线程修改的变量
- 临界区是指访问某一共享资源的代码片段，并且这段代码的执行应为原子操作，也就是同时访问同一共享资源的其他线程不应中断该片段的执行
- 线程同步：即当有一个线程在对内存进行操作时，其他线程都不可以对这个内存地址进行操作，直到该线程完成操作，其他线程才能对该内存地址进行操作，而其他线程则处于等待状态
- 互斥量

	- 已锁定
	- 未锁定
	- 任何时候，至多只有一个线程可以锁定该互斥量
	- int pthread_mutex_init(pthread_mutex_t *restrict mutex,const pthread_mutexattr_t *restrict attr);

		- 初始化互斥量
		- 参数

			- mutex：需要初始化的互斥量变量
			- attr：互斥量相关的属性，NULL

		- - restrict：C语言的修饰符，被修饰的指针，不能由另外的一个指针进行操作

	- int pthread_mutex_destroy(pthread_mutex_t *mutex);

		- - 释放互斥量的资源

	- int pthread_mutex_lock(pthread_mutex_t *mutex);

		- - 加锁，阻塞的，如果有一个线程加锁了，那么其他的线程只能阻塞等待

	- int pthread_mutex_trylock(pthread_mutex_t *mutex);

		- - 尝试加锁，如果加锁失败，不会阻塞，会直接返回

	- int pthread_mutex_unlock(pthread_mutex_t *mutex);

		- - 解锁

- 死锁

	-  场景

		- 忘记释放锁
		- 重复加锁
		- 多线程多锁，抢占锁资源

- 读写锁

	- 在对数据的读写操作中，更多的是读操作，写操作较少，例如对数据库数据的读写应用。为了满足当前能够允许多个读出，但只允许一个写入的需求，线程提供了读写锁来实现。
	- 读写锁的特点

		- 如果有其它线程读数据，则允许其它线程执行读操作，但不允许写操作
		- 如果有其它线程写数据，则其它线程都不允许读、写操作
		- 写是独占的，写的优先级高

- 生产者消费者模型

	- 对象

		- 1.生产者
		- 2.消费者
		- 3.容器

- 条件变量

	- 条件变量之所以要和互斥锁一起使用，主要是因为互斥锁的一个明显的特点就是它只有两种状态：锁定和非锁定，而条件变量可以通过允许线程阻塞和等待另一个线程发送信号来弥补互斥锁的不足，所以互斥锁和条件变量通常一起使用
	- 当条件满足的时候，线程通常解锁并等待该条件发生变化，一旦另一个线程修改了环境变量，就会通知相应的环境变量唤醒一个或者多个被这个条件变量阻塞的线程。这些被唤醒的线程将重新上锁，并测试条件是否满足。一般来说条件变量被用于线程间的同步；当条件不满足的时候，允许其中的一个执行流挂起和等待

- 信号量

	- int sem_init(sem_t *sem,int pshared,unsigned int value);

		- 作用：初始化信号量
		- 参数

			- - sem：信号量变量的地址
			- - pshared：0 用在线程间 非0 用在进程间
			- - value：信号量中的值

	- int sem_destroy(sem_t *sem);

		- 作用：释放资源

	- int sem_wait(sem_t *sem);

		- - 对信号量的值减1，如果值为0 就阻塞

	- int sem_post(sem_t *sem);

		- - 对信号量解锁，调用一次对信号量的值+1

