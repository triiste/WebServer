# 第2章 LInux多进程开发

## 2.1 进程概述

### 1.程序和进程

- 程序是包含一系列信息的文件
- 进程是正在运行的程序的实例。是一个具有一定独立功能的程序关于某个数据集合的一次运行活动。

### 2.单道、多道程序设计

- 单道程序：在计算机内存中只允许一个程序允许
- 多道程序：同时存放多道相互独立的程序，相互穿插运行
- 单CPU，微观而言，任意时刻只能运行一个程序

### 3.时间片

- 是操作系统分配给每个正在运行的进程微观上的一段CPU时间

### 4.并行和并发

- 并行：指在同一时刻，有多条指令在多个处理器上同时执行
- 并发：同一时刻只能有一个指令执行，但多个进程指令被快速轮换执行，使得在宏观上具有多个进程同时执行的效果

### 5.进程控制块

- 进程id
- 进程的状态
- 进程切换时需要保存和恢复的一些CPU寄存器
- 描述虚拟地址空间的信息
- 描述控制终端的信息
- 当前工作目录
- umask掩码
- 文件描述符表
- 和信号相关的信息
- 用户id和组id
- 会话和进程组
- 进程可以使用的资源上限

## 2.进程状态转换

### 1.进程的状态

- 三态模型

	- 就绪态
	- 运行态
	- 阻塞态

- 五态模型

	- 新建态

		- 

	- 终止态

### 2.进程相关命令

- 查看进程

	- ps aux / ajx

		- a：显示终端上的所有进程，包括其他用户的i进程
		- u:显示进程的详细信息
		- x:显示没有控制终端的进程
		- j:列出与作业控制相关的信息

- 实时显示进程动态

	- top

- 杀死进程

	- kill -9 PID

		- 9：SIGKILL

			- 强制杀死进程

	- killall name
	- 运行后面＋ &

		- 表示后台运行
		- 前台运行 当前终端被阻塞

### 3.进程号和相关函数

- 每个进程由进程号标识，其类型为pid_t(整型)，进程号的范围：0~32767

	- 进程号唯一，但可重用
当一个进程终止后，其进程号就可以再次使用

- 任何进程(除 init进程)都是由另一个进程创建，该进程称为被创建进程的父进程，对应的进程号称为父进程号(PPID)
- 进程组是一个或多个进程的集合。
- 进程号和进程组相关函数

	- pid_t  getpid(void);
	- pid_t  getppid(void);
	- pid_t  getpgid(pid_t pid);

## 3.进程创建

### 1.进程创建

- 系统允许一个进程创建新进程，新进程即为子进程，子进程还可以创建新的子进程，形成进程树结构模型

	- pid_t fork(void)

		- 函数的作用：用于创建子进程
		- 返回值会返回两次：
      成功：子进程中返回0，父进程中返回子进程ID
      失败：父进程返回-1，没有子进程
		- 失败的两个主要原因：

			- 1.当前系统的进程数已经达到上限
			- 2.系统内存不足

## 4.父子进程虚拟地址空间情况

### fork之后 子进程的用户去和父进程的数据区一致

### 内核区 pid不一致

### 一开始是共享空间，fork子进程在进行写的时候才开始复制，称为写时拷贝

## 5.GDB多进程调试

### 父子进程之间的关系：

- 区别

	- 1.fork()函数的返回值不同
        父进程中：>0 返回子进程的ID
        子进程中：=0
	- 2.pcb中的一些数据
      当前进程的id pid
      当前的进程的父进程的id ppid
      信号集

- 共同点

	- 某些状态下：子进程刚被创建出来，还没有执行任何写数据的操作:用户区的数据，文件描述符表 

- 父子进程对变量是不是共享的？

	- 刚开始的时候，是一样的，共享的。如果修改了数据，不共享了。
	- 读时共享(子进程被创建，两个进程没有做任何写的操作)，写时拷贝

### GDB多进程调试

- 默认跟踪父进程

	- set follow-fork-mode child
	- show detach-on-fork

		- on 子进程脱离父进程的控制(调试父进程时，子进程正常运行)
		- off 子进程不脱离控制，挂起在fork的地方

- info inferiors 查看进程

	- inferior 1 切换当前调试的进程
	- detach inferiors 2  使进程脱离gdb调试

## 6.exec函数族

### exec 函数族的作用是根据指定的文件名找到可执行文件，并用它来取代调用进程的内容，换句话说，就是在调用进程内部执行一个可执行文件

### exec函数族的函数执行成功后不会返回，因为调用进程的实体，包括代码段，数据段和堆栈等都已经被新的内容取代，只留下进程ID等一些表明上的信息仍保持原样

### exec("a.out",...)

- 替换原先用户区的数据为a.out里面的数据

### int execl(const char *path, const char *arg,...);

- int execl(const char *path, const char *arg,...);
 -参数：
    -path:需要指定执行的文件的路径或者名称
          a.out /home/wcf/a.out 推荐使用绝对路径
    -arg:是执行可执行文件所需要的参数列表
     第一个参数一般没有什么作用，为了方便，一般写的是执行的程序的名称
     从第二个参数开始往后，就是程序执行所需要的参数列表
     参数最后需要以NULL结束(哨兵)
- -返回值：
 调用成功无返回值，调用失败返回-1

### int execlp(const char *file, const char *arg,...);

- 与上述不同，会到环境变量中查找指定的可执行文件，如果找到了会执行，如果没找到执行不成功！
- p(path):按PATH环境变量指定的目录搜索可执行文件

## 7.进程退出、孤儿进程、僵尸进程

### 进程退出

- void exit(int status)

	- 刷新I/O缓冲，关闭文件描述符 最后调用exit()系统调用

		- 将缓冲区数据刷新到控制台！！！

	- status参数：是进程退出时的一个状态信息。父进程回收子进程资源的时候可以获取到

### 孤儿进程

- 父进程运行结束，但子进程还在运行(未运行结束)，这样的子进程就称为孤儿进程
- 每当出现一个孤儿进程，内核就把孤儿进程的父进程设置为init,而init进程会循环地wait()它的已经退出的子进程
- 没有危害，最终会善后

### 僵尸进程

- 每个进程结束之后，都会释放自己地址空间中的用户区数据，内核区的PCB没有办法自己释放掉，需要父进程去释放
- 僵尸进程不能被 kill -9 杀死
- 如果不释放，进程号就会一直被占用，但是系统能使用的进程号是有限的，如果大量的产生僵尸进程，将因为没有可用的进程号而导致系统不能产生新的进程，即为僵尸进程的危害，应当避免

## 8.进程回收

### wait()

- wait()函数会阻塞

	- 功能：等待任意一个子进程结束，如果任意一个子进程结束，此函数会回收子进程的信息
	- 参数：int *wstatus
       进程退出时的状态，传入的是一个int类型的地址，传出参数
	- 返回值：
     - 成功：返回被回收的子进程的id
     - 失败：返回-1

- 调用wait函数的进程会被挂起(阻塞)，直到它的一个子进程退出或者收到一个不能忽略的信号时的信号时才被唤醒（相当于继续往下执行）
- 如果没有子进程了，函数立刻返回，返回-1；如果子进程都已经结束了，也会立即返回，返回 -1
- 退出信息相关宏函数

	- 

### waitpid()

- pid_t waitpid(pid_t pid, int *wstatus, int options);

	- 功能：回收指定进程号的子进程，可以设置是否阻塞

		- 子主题 1

	-  - pid:

		- pid > 0 : 某个子进程的pid
		- pid == 0: 回收当前进程组的所有子进程
		- pid == -1:回收所有的子进程，相当于wait()(最常用)
		- pid < -1 : 某个进程组的组id绝对值，回收指定进程组的子进程

	- - options:设置阻塞或者非阻塞

		- 0:阻塞
		- WNOHANG:非阻塞

	- 参数：int *wstatus
       进程退出时的状态，传入的是一个int类型的地址，传出参数
	- - 返回值：

		- >0 : 返回子进程的id
		- =0 : options=WNOHANG时,表示还有子进程活着，没有退出
		- =-1: 错误，或者没有子进程了

- waitpid()函数可以设置不阻塞，waitpid()还可以指定等待哪个子进程结束

## 9.进程间通信

### 1.进程间通讯概念

- 进程是一个独立的资源分配单元，不同进程之间的资源是独立的，没有关联，不能在一个进程中直接访问另一个进程的资源
- 进程不是孤立的，不同的进程需要进行信息的交互和状态的传递等，因此需要进程间通信
- 进程间通信的目的

	- 数据传输
	- 通知事件
	- 资源共享
	- 进程控制

### 2.Linux进程间通信方式

- 同一主机进程间通信

	- Unix进程间通信方式

		- 匿名管道
		- 有名管道
		- 信号

	- System V进程间通信方式
	- POIX进程间通信方式

- 不同主机(网络)进程间通信

	- Socket

### 3.匿名管道

- 管道也叫无名管道，它是UNIX系统IPC(进程间通信)的最古老形式，所有的UNIX系统都支持这种通信机制
- 管道的特点

	- 管道其实是一个在内核内存中维护的缓冲器
	- 管道拥有文件的特质：读操作、写操作。匿名管道没有文件实体，有名管道有文件实体，但不存储数据。可以按照操作文件的方式对管道进程操作
	- 一个管道是一个字节流，使用管道时不存在消息或者消息边界的概念，从管道读取数据的进程可以读取任意大小的数据块
	- 通过管道传递的数据是顺序的
	- 半双工 单向传递
	- 匿名管道只能在具有公共祖先的进程(父进程与子进程，或者两个兄弟进程，具有亲缘关系)之间使用
	- 为什么可以使用管道进行进程间通信？

		- 父子进程共享文件描述符表

	- 数据结构为循环队列

- 匿名管道的使用

	- #include <unistd.h>
int pipe(int pipefd[2]);

		- 功能：创建一个匿名管道，用来进程间通信。
		- 参数：int pipefd[2] 这个数组是一个传出参数
          pipefd[0] 对应的是管道读端
          pipefd[1] 对应的是管道的写端
		- 返回值：成功返回0，失败返回-1
		- 注意：匿名管道只能用于具有关系的进程之间的通信(父子进程，兄弟进程)
		- 管道默认是阻塞的：如果管道中没有数据，read阻塞，如果管道满了，write阻塞

	- ulimit -a

		- 查看管道大小

- 管道的读写特点和管道设置为非阻塞

	- 管道的读写特点

		- 使用管道时，需要注意以下几种特殊的情况(假设都是阻塞I/O操作)

			- 1.所有的指向管道写端的文件描述符都关闭了（管道写端引用计数为0），进程从管道的读端读数据，那么管道中剩余的数据被读取以后，再次read会返回0，就像读到文件末尾一样
			- 2.如果有指向管道写端的文件描述符没有关闭（管道的写端引用计数大于0），而持有管道写端也没有往管道中写数据，这个时候有进程从管道中读取数据，那么管道中剩余数据被读取后，再次read会阻塞，直到管道中有数据可以读才读取数据并返回
			- 3.如果所有指向管道读端的文件描述符都关闭了（管道的读端引用计数等于0），这时有进程向管道写数据，那么该进程会收到一个信号SIGPIPE,通常会导致进程异常终止
			- 4.如果有指向管道读端的文件描述符没有关闭（管道的读端引用计数大于0），而持有管道读端的进程也没有从管道中读数据，这时有进程往管道中写数据，在管道被写满时，再次调用write会阻塞，直到管道有空位置才能再次写入数据并返回

		- 总结

			- 读管道：

				- 管道中有数据，read返回实际读到的字节数
				- 管道中无数据

					- 写端被全部关闭，read返回0(相当于读到文件的末尾)
					- 写端没有完全关闭，read阻塞等待

			- 写管道

				- 管道读端全部被关闭，进程异常终止（进程收到SIGPIPE信号）
				- 管道读端没有全部关闭

					- 管道已满，write阻塞
					- 管道没有满，write将数据写入

### 4.有名管道

- 匿名管道，由于没有名字，只能用于亲缘关系的进程间通信。为了克服这个缺点，提出了有名管道(FIFO),也叫命名管道、FIFO文件
- 有名管道提供一个路径名与之关联，以FIFO的文件形式存在于文件系统中，并且其打开方式与打开一个普通文件是一样的
- 与匿名管道不同之处

	- 1.FIFO在文件系统中作为一个特殊文件存在，但FIFO中的内容却存放在内存中
	- 2.当使用FIFO的进程退出后，FIFO文件将继续保存在文件系统中以便以后使用
	- 3.FIFO有名字，不相关的进程可以通过打开有名管道进程通信

- 使用

	- 创建fifo文件

		- 1.通过命令:mkfifo 名字
		- 2.通过函数：int mkfifo(const char *pathname,mode_t mode)

			- 参数

				- pathname:管道名称的路径
				- mode:文件的权限，和open的mode是一样的,是一个八进制的数

			- 返回值

				- 成功 返回 0  失败返回 -1，并设置错误号

- 有名管道的注意事项：

	- 1.一个为只读而打开一个管道的进程会阻塞，直到另外一个进程为只写打开管道
	- 2.一个为只写而打开一个管道的进程会阻塞，直到另外一个进程为只读打开管道

- 读管道：

	- 管道中有数据

		- read返回实际读到的字节数

	- 管道中无数据

		- 管道写端被全部关闭

			- read返回0，相当于读到文件末尾

		- 写端没有被全部关闭，read阻塞等待

- 写管道：

	- 管道读端被全部关闭

		- 进程异常终止（收到一个SIGPIPE）

	- 管道读端没有全部关闭

		- 管道已经满了，write会阻塞
		- 管道没有满，write将数据写入，并返回实际写入的字节数

### 5.内存映射

- 内存映射是将磁盘文件的数据映射到内存，用户通过修改内存就能修改磁盘文件

	- 子主题 1

- void *mmap(void *addr, size_t length, int prot, int flags,int fd, off_t offset);

	- - 功能:将一个文件或者设备的数据映射到内存中
	- - 参数:

		- - void *addr:NULL,由内核指定
		- - length：要映射的数据的长度，这个值不能为0.建议使用文件的长度
		- -prot：对申请的内存映射区的操作权限 
           -PROT_EXEC：可执行的权限
           -PROT_READ：读权限
           -PROT_WRITE：写权限
           -PROT_NONE：没有权限

			- 要操作映射内存，必须要有读的权限

		- -flags:
      - MAP_SHARED：映射区的数据会自动和磁盘文件进行同步，进程间通信，必须要设置这个选项
      - MAP_PRIVATE: 不同步，内存映射区的数据改变了，对原来的文件不会修改，会重新创建一个新的文件(copy on write)
		- -fd 需要映射的那个文件描述符
        - 通过open得到，open的是一个磁盘文件
        - 注意:文件的大小不能为0，open指定的权限不能和prot参数有冲突

			- PROT_READ

				- open:只读/读写

			- PROT_READ | PROT_WRITE

				- open:读写

			- prot要小于open的权限

		- - offset：偏移量，一般不用。必须指定的是4k的整数倍，0表示不偏移

	- 返回值

		- 返回创建的内存的首地址
		- 失败 返回 MAP_FAILED

- int munmap(void *addr, size_t length);

	- 功能：释放内存映射
	- 参数

		- addr:要释放的内存的首地址
		- length:要释放的内存的大小，要和mmap函数中的参数的值一样

- 使用内存映射实现进程间通信

	- 1.有关系的进程(父子进程)

		- 还没有子进程的时候，通过唯一的父进程，先创建内存映射区
		- 有了内存映射区以后，创建子进程
		- 父子进程共享创建的内存映射区

	- 2.没有关系的进程间通信

		- 准备一个大小不是0的磁盘文件
		- 进程1 通过磁盘文件创建内存映射区
     -得到一个操作这块内存的指针
		- 进程2 通过磁盘文件创建内存映射区
     -得到一个操作这块内存的指针
		- -使用内存映射区通信

	- 注意：内存映射区通信，是非阻塞

- 思考问题

	- 1.如果对mmap的返回值(ptr)做++操作(ptr++),munmap是否能够成功？

		- void *ptr = mmap(...);
		- ptr++;可以对其进行++操作（不建议）
		- munmap(ptr,len); //错误

	- 2.如果open时O_RDONLY,mmap是 prot参数指定 PROT_READ | PROT_WRITE 会怎样？

		- 错误，返回MAP_FAILED
		- open()函数中的权限建议和prot参数的权限保持一致 （prot要小于open的权限）

	- 3.如果文件偏移量为1000会怎样？

		- 偏移量必须是4k的整数倍
		- 错误，返回 MAP_FAILED

	- 4.mmap什么情况下会调用失败？

		- 第二个参数:length=0
		- 第三个参数：prot
     - 只指定了写权限
     - prot PROT_READ | PROT_WRITE
      第5个参数fd 通过open函数时指定的 O_RDONLY / O_WRONLY

	- 5.可以以open的时候O_CREAT一个新文件来创建映射区吗？

		- 可以的，但是创建的文件的大小如果为0的话，肯定不行
		- 可以对新的文件进行扩展

			- lseek()
			- truncate()

	- 6.mmap后关闭文件描述符，对mmap映射有没有影响？

		- int fd = open("xxx")
mmap(,,,, fd,0);
close(fd);
		- 映射区还存在，创建映射区的fd被关闭，没有任何影响

	- 7.对ptr越界操作会怎样？

		- void *ptr = mmap(NULL,100,,,,,)
		- 越界操作操作的是非法的内存 -> 段错误

- 另一种用途

	- 可以做文件拷贝

- 匿名映射

	- void *mmap(void *addr, size_t length, int prot, int flags,int fd, off_t offset);

		- flags

			- MAP_ANONYMOUS：表示匿名映射

				- 不需要文件实体进程的一个内存映射

		- mmap(NULL,len,PROT_READ | PROT_WRITE,MAP_SHARED | MAP_ANONYMOUS,-1,0);

### 6.信号

- 信号是Linux进程间通信的最古老的方式之一，是事件发生时对进程的通知机制，有时也称之为软件中断，它是在软件层次上对中断机制的一种模拟，是一种异步通信的方式
- 信号可以导致一个正在运行的进程被另一个正在运行的异步进程中断，转而处理某一个突发事件
- 发往进程的诸多信号，通常都是源于内核。引发内核为进程产生信号的各类事件

	- 对于前台进程

		- 用户通过输入特殊的终端字符来给它发送信号

	- 硬件发生异常

		- 诸如被0除，或者引用了无法访问的内存区域

	- 系统状态变化

		- alarm定时器到期将引起SIGALRM信号、进程执行的CPU时间超限，或者该进程的某个子进程退出

	- 运行kill命令或调用kill函数

- 信号的概念

	- 使用信号的两个主要目的

		- 1.让进程知道已经发送了一个特定的事情
		- 2.强迫进程执行它自己代码中的信号处理程序

	- 信号的特点

		- 简单
		- 不能携带大量信息
		- 满足某个特定条件才发送
		- 优先级比较高

	- 查看系统定义的信号列表

		- kill -l

	- 前31个信号为常规信号，其余为实时信号

- Linux 信号一览表

	- 2 SIGINT 

		- 当用户按下了<Ctrl+C>组合键时，用户终端向正在运行中的由该终端启动的程序发出此信号

			- 终止进程

	- 3 SIGQUIT

		- 用户按下<Ctrl + \>，用户终端向正在运行中的由该终端启动的程序发出此信号

			- 终止进程

	- 9 SIGKILL

		- 无条件终止进程。该信号不能被忽略，处理和阻塞

			- 终止进程

	- 11 SIGSEGV

		- 指示进程进行了无效内存访问(段错误)

			- 终止进程并产生core文件

	- 13 SIGPIPE

		- Broken pipe向一个没有读端的管道写数据

			- 终止进程

	- 17 SIGCHLD

		- 子进程结束时，父进程会收到这个信号

			- 忽略这个信号

	- 18 SIGCONT

		- 如果进程已停止，则使其继续运行

			- 继续/忽略

	- 19 SIGSTOP

		- 停止进程的执行。信号不能被忽略、处理、阻塞

			- 终止进程

- 信号的5种默认处理动作

	- 终止进程
	- 当前进程忽略掉这个信号
	- 终止进程，并生成一个Core文件
	- 暂停当前进程
	- 继续执行当前被暂停的进程
	- 信号的几种状态

		- 产生
		- 未决
		- 递达

- 信号相关的函数

	- int kill(pid_t pid, int sig);

		- 功能:给某个进程pid,发送某个信号
		- 参数

			- pid:需要发送给的进程的id

				- pid>0

					- 将信号发送给指定的进程

				- pid=0

					- 将信号发送给当前的进程组

				- pid=-1

					- 将信号发送给每一个有权限接收这个信号的进程

				- pid<-1

					- 这个pid等于某个进程组的id取反

			- sig:需要发送的信号的编号或者是宏值，0表示不发送任何信号

		- 举例

			- kill(getpid(),9)
			- kill(getppid(),9)

	- int raise(int sig);

		- 功能：给当前进程发送信号   
		- 参数

			- sig:要发送的信号

		- 返回值

			- 成功返回0  失败返回 非0

		- 举例

			- kill(getpid(),sig);

	-  void abort(void);

		- 功能：发送SIGABRT信号给当前的进程，杀死当前进程
		- 与此函数 kill(getpid(),SIGABRT); 类似

	- unsigned int alarm(unsigned int seconds);

		- 功能：设置定时器(闹钟)。函数调用，开始倒计时，当倒计时为0，函数会给当前的进程发送一个信号：SIGALRM
		- 参数：seconds：倒计时的时长，单位:秒。如果参数为0,定时器无效(不进行倒计时，不发信号)

			- 取消一个定时器,通过alarm(0)

		- 返回值

			- 之前没有定时器 返回0
			- 之前有定时器，返回上一个定时器剩余的时间

		- SIGALRM:默认终止当前的进程，每一个进程都有且只有唯一的一个定时器

			- alarm(10)
过了1秒
alarm(5);

				- 以最新的为准，把之前的覆盖掉！

		- alarm函数是不阻塞的
		- 实际的实际 = 内核时间 + 用户时间 + 消耗的时间

			- 进行文件IO操作的时候比较浪费时间
			- 内核和用户区时间切换

		- 定时器：与进程的状态无关(自然定时法)。无论进程处于什么状态，alarm都会计时

	- int setitimer(int which,const struct itimerval *new_val,struct itimerval *old_value);

		- 功能：设置定时器(闹钟)。可以替代alarm函数。精度微妙us,可以实现周期性定时
		- which:定时器以什么时间计时

			- ITIMER_REAL

				- 真实时间，时间到达，发送 SIGALARM 常用

			- ITIMER_VIRTUAL

				- 用户时间，时间到达，发送SIGVTALRM

			- ITIMER_PROF

				- 以该进程在用户态和内核态消耗的时间来计算，时间到达，发送SIGPROF

		- new_val

			- struct itimerval{
  struct timeval it_interval;
  struct timeval it_value;
}

				- it_interval; //每个阶段的时间，间隔时间
				- it_value; //延迟多长时间执行定时器
				- struct timeval{
   time_t tv_sec;
   suseconds_t tv_usec;
}

					- tv_sec : 秒数
					- tv_usec:微妙

				- 过10秒后，每隔2秒定时一次

					- 10秒：it_value
					- 2秒: it_interval

			- 设置定时器的属性

		- old_value

			- 记录上一次定时的时间参数，一般不使用，指定NULL

		- 返回值

			- 成功返回0 失败返回-1，并设置错误号

		- 延迟的时间是第一次定时，定时到之后函数会给当前的进程发送一个信号：SIGALRM终止信号

- signal信号捕捉函数

	- sighandler_t signal(int signum, sighandler_t handler);

		- 功能：设置某个信号的捕捉行为
		- 参数：
     - signum:要捕捉的信号
     - handler:捕捉到信号要如何处理
          - SIG_IGN：忽略信号
          - SIG_DFL：使用信号默认的行为
          - 回调函数：这个函数是内核调用，程序员只负责写，捕捉到信号后如何去处理信号
		- 回调函数

			- 需要程序员实现，提前准备好的，函数的类型根据实际需求，看函数指针的定义
			- 不是程序员调用，而是当信号产生，由内核调用
			- 函数指针是实现回调的手段，函数实现之后，将函数名放到函数指针的位置就可以了

		- 返回值

			- 成功：返回上一次注册的信号处理函数的地址。第一次调用返回NULL
			- 失败：返回SIG_ERR,设置错误号

	- 9 SIGKILL、19 SIGSTOP 不能被捕捉，不能被忽略

- 信号集及相关函数

	- 内核区PCB中

		- 用户通过键盘 Ctrl + C,产生2号信号SIGINT(信号被创建)

			- 信号产生但是没有被处理(未决)
    - 在内核中将所有的没有被处理的信号存储在一个集合中(未决信号集)
    - SIGINT信号状态被存储在第二个标志位

				- 标志位的值为 0 说明信号不是未决状态
				- 标志位的值为1 说明信号是未决状态

			- 未决状态的信号，需要被处理，处理之前需要和另一个信号集(阻塞信号集)，进行比较

				- 阻塞信号集默认不阻塞任何的信号
				- 如果想要阻塞某些信号需要用户调用系统的API

			- 在处理的时候和阻塞信号集中的标志位进行查询，看是不是对该信号设置阻塞了

				- 如果没有阻塞，这个信号就被处理
				- 如果阻塞了，这个信号就继续处于未决状态，直到阻塞解除，这个信号就被处理

	- 以下信号集相关的函数都是对自定义的信号集进行操作
	- int sigemptyset(sigset_t *set)

		- 功能：清空信号集中的数据，将信号集中所有的标志位置为0
		- 参数：set，传出参数，需要操作的信号集
		- 返回值

			- 成功 返回0 失败返回 -1

	- int sigfillset(sigset_t *set)

		- 功能：清空信号集中的数据，将信号集中所有的标志位置为1
		- 参数：set，传出参数，需要操作的信号集
		- 返回值

			- 成功 返回0 失败返回 -1

	- int sigaddset(sigset_t *set,int signum)

		- 功能：设置信号集中的某一个信号对应的标志位为1，表示阻塞这个信号
		- 参数

			- set 传出参数，需要操作的信号集
			- signum:需要设置阻塞的信号

		- 返回值 成功返回0 失败返回-1

	- int sigdelset(sigset_t *set,int signum);

		- 功能：设置信号集中的某一个信号对应的标志位为1，表示不阻塞这个信号
		- 参数

			- set 传出参数，需要操作的信号集
			- signum:需要设置不阻塞的信号

		- 返回值 成功返回0 失败返回-1

	- int sigismember(const sigset_t *set,int signum);

		- 功能：判断某个信号是否阻塞
		- 参数

			- -set 需要操作的信号集
			- -signum:需要判断的那个信号

		- 返回值

			- 1：signum被阻塞
0：signum不阻塞
-1：调用失败

	- int sigprocmask(int how, const sigset_t *set, sigset_t *oldset);

		- 功能：将自定义信号集中的数据设置到内核中（设置阻塞、解除阻塞、替换）
		- 参数

			- how

				- 如何对内核阻塞信号集进行处理
				- SIG_BLOCK：将用户设置的阻塞信号集添加到内核中，内核中原来的数据不变

					- 假设内核中默认的阻塞信号集是mask，mask | set

				- SIG_UNBLOCK:

					- 根据用户设置的数据，对内核中的数据进行解除阻塞 mask &= ~set

			- set

				- 已经初始化好的用户自定义的信号集

			- oldset

				- 保存设置之前的内核 中的阻塞信号集的状态，可以是NULL

		- 返回值

			- 成功返回0 失败返回-1 并且设置错误号

	- int sigpending(sigset_t *set);

		- 功能

			- 获取内核中的未决信号集

		- 参数

			- set 传出参数，保存的是内核中的未决信号集中的信息

		- 返回值

			- 成功返回0 失败返回-1

	- int sigaction(int signum, const struct sigaction *act,struct sigaction *oldact);

		- 功能：检查或者改变信号的处理。信号捕捉
		- 参数

			- - signum:需要捕捉的信号的编号或者宏值（信号的名称）
			- - act:捕捉信号之后的处理动作
			- - oldact: 上一次对信号捕捉相关的设置，一般不使用，传递NULL

		- 返回值

			- 成功 0
			- 失败 -1

		-            struct sigaction {
//函数指针，指向的函数就是信号捕捉到之后的处理函数
               void     (*sa_handler)(int);
//不常用
               void     (*sa_sigaction)(int, siginfo_t *, void *);
//临时阻塞信号集，在信号捕捉函数执行过程中，临时阻塞某些信号
               sigset_t   sa_mask;
//使用哪一个信号处理对捕捉到的信号进行处理
//这个值可以是0，表示使用sa_handler,也可以是SA_SIGINFO表示使用sa_sigaction
               int        sa_flags;
//被废弃掉了
               void     (*sa_restorer)(void);
           };

- 内核实现信号捕捉的过程

	- 1.在执行主控制流程的某条指令时因为中断、异常或系统调用进入内核
	- 2.内核处理完异常准备回用户模式之前先处理当前进程中可以递送的信号
	- 3.如果信号的处理动作为自定义的信号处理函数，则回到用户模式执行信号处理函数(而不是回到主控制流程)
	- 4.信号处理函数返回时执行特殊的系统调用sigreturn 再次进入内核
	- 5.返回用户模式从主控制流程中上次被中断的地方继续向下执行

- SIGCHLD信号

	- 产生条件

		- 1.子进程终止时
		- 2.子进程接收到SIGSTOP信号停止时
		- 3.子进程处在停止态，接受到SIGCONT后唤醒时

### 7.共享内存

- 允许两个或者多个进程共享物理内存的同一块区域(通常被称为段)。
- 使用shmat()来附上共享内存段，即使该段成为调用进程的虚拟内存的一部分。为引用这块共享内存，程序需要使用由shmat()调用返回的addr值，它是一个指向进程的虚拟地址空间中该共享内存段的起点的指针
- 调用shmdt()来分离共享内存段
- 调用shmctl()来删除共享内存段
- 相关函数

	- int shmget(key_t key,size_t size,int shmflg);

		- 功能

			- 创建一个新的共享内存段或取得一个既有共享内存段的标识符。新创建的内存段中的数据都会被初始化为0

		- 参数

			- - key ：key_t类型是一个整型，通过这个找到或者创建一个共享内存，一般使用16进制表示，非0值
			- - size：共享内存的大小
			- - shmflg：属性

				- - 访问权限
				- - 附加属性：创建/判断 共享内存是不是存在
				- 创建: IPC_CREAT
				- 判断共享内存是否存在：IPC_EXCL,需要和IPC_CREAT一起使用

					- IPC_CREAT | IPC_EXCL | 0664

		- 返回值

			- 失败：返回 -1 并设置错误号
			- 成功：>0 返回共享内存的引用的ID,后面操作共享内存都是通过这个值。

	- void *shmat(int shmid,const void *shmaddr,int shmflg);

		- 功能

			- 和当前的进程进行关联

		- 参数

			- - shmid：共享内存的标识(ID)，由shmget返回值获取
			- - shmaddr：申请的共享内存的起始地址，指定NULL
			- - shmflg：对共享内存的操作

				- -读：SHM_RDONLY，必须要有读权限
				- -读写：0

		- 返回值

			- 成功：返回共享内存的首(起始)地址。
			- 失败 返回 （void *） -1

	- int shmdt(const void *shmaddr);

		- 功能

			- 解除当前进程和共享内存的关联

		- 参数

			- shmaddr:共享内存的首地址

		- 返回值

			- 成功 0
			- 失败 -1

	- int shmctl(int shmid,int cmd,struct shmid_ds *buf)

		- 功能

			- 对共享内存进行操作。

		- 参数

			- - shmid：共享内存的ID
			- - cmd：要做的操作

				- - IPC_STAT：获取共享内存的当前的状态
				- - IPC_SET：设置共享内存的状态
				- - IPC_RMID：标记共享内存被销毁

			- - buf：需要设置或者获取的共享内存的属性信息

				- - IPC_STAT：buf存储数据
				- - IPC_SET：buf中需要初始化数据，设置到内核中
				- - IPC_RMID：没有用，NULL

	- key_t ftok(const char *pathname,int proj_id);

		- 功能：根据指定的路径名，和int值，生成一个共享内存的key
		- 参数

			- -pathname

				- 指定一个存在的路径

			- -proj_id

				- int类型的值，但是这个系统调用只会使用其中的1个字节
				- 范围：0-255 一般指定一个字符 'a'

- 总结

	- 问题1：操作系统如何知道一块共享内存被多少个进程关联？

		- - 共享内存维护了一个结构体stuct shmid_ds 这个结构体中有一个成员 shm_nattach
		- - shm_nattach 记录了关联的进程的个数

	- 问题2：可不可以对共享内存进行多次删除 shmctl

		- - 可以的
		- - 因为shmctl 标记删除共享内存，而不是直接删除
		- -什么时候真正删除呢？

			- 当和共享内存关联的进程数为0的时候，就真正被删除

		- -当共享内存的key为0的时候 ，共享内存被标记删除了
		- 如果一个进程和共享内存取消关联，不能继续操作共享内存，也不能再次关联

	- 共享内存和内存映射的区别

		- 1.共享内存可以直接创建，内存映射需要磁盘文件（匿名映射除外）
		- 2.共享内存效率更高 不需要跟磁盘文件进行操作
		- 3.内存

			- 所有的进程操作的是同一块共享内存
			- 内存映射，每个进程在自己的虚拟地址空间中有一块独立的内存

		- 4.数据安全

			- - 进程突然退出

				- 共享内存还存在
				- 内存映射区消失

			- - 运行进程的电脑死机，宕机了

				- 数据存在在共享内存中，没有了
				- 内存映射区的数据，由于磁盘文件中的数据还在，所有内存映射区的数据还在

		- 5.生命周期

			- - 内存映射区：进程退出，内存映射区销毁
			- - 共享内存：进程退出，共享内存还在，标记删除(所有的关联的进程数为0)；或者关机
			- 如果一个进程退出，会自动和共享内存进行取消关联

### 8.守护进程

- 终端

	- 进程中，控制终端是保存在PCB中的信息，而fork()会复制PCB中的信息
	- 默认情况下(没有重定向)，每个进程的标准输入、标准输出和标准错误都指向控制终端 
	- 在控制终端输入一些特殊的控制键可以对前台进程发信号

- 进程组

	- 进程组是一组相关进程的集合，会话是一组相关进程组的集合
	- 进程组由一个或多个共享同一进程组标识符(PGID)的进程组成。新进程会继承其父进程所属的进程组ID
	- 进程组拥有一个生命周期，其开始时间为首进程创建组的时刻，结束时间为最后一个成员进程退出组的时刻。一个进程因终止退出或加入另一个进程组退出。

- 会话

	- 会话是一组进程组的集合。会话首进程是创建该新会话的进程，其进程ID会称为会话ID。新进程会继承其父进程的会话ID。
	- 一个会话中的所有进程共享单个控制终端。控制终端会在会话首进程首次打开一个终端设备时被建立。一个终端最多可能会成为一个会话的控制终端
	- 在任一时刻，会话中的其中一个进程组会成为成为终端的前台进程组，其他进程组会成为后台进程组

- 进程组、会话操作函数

	- pid_t getpgrp(void)
	- pid_t getpgid(pid_t pid)
	- int setpgid(pid_t pid,pid_t pgid);
	- pid_t getsid(pid_t pid);
	- pid_t setsid(void);

- 守护进程

	- Daemon进程(精灵进程)。一般采用以d结尾的名字
	- 守护进程的特点

		- 生命周期很长，守护进程会在系统启动的时候被创建并一直运行直至系统被关闭
		- 它在后台运行并且不拥有控制终端

	- 守护进程的创建步骤

		- 执行一个fork(),之后父进程退出，子进程继续执行
		- 子进程调用setsid()开启一个新会话
		- 清除进程的umask以确保当守护进程创建文件和目录时拥有所需的权限
		- 修改进程的当前工作目录，通常会改为根目录(/)
		- 关闭守护进程从其父进程继承而来的所有打开着的文件描述符
		- 在关闭了文件描述符0、1、2之后，守护进程通常会打开/dev/null，并使用dup2()使所有这些描述符指向这个设备
		- 核心业务逻辑

